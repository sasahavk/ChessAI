import chess

piece_values = {
    chess.PAWN: 100,
    chess.KNIGHT: 320,
    chess.BISHOP: 330,
    chess.ROOK: 500,
    chess.QUEEN: 900,
    chess.KING: 0,
}

pawn_table = [
    0, 0, 0, 0, 0, 0, 0, 0,
    50, 50, 50, 50, 50, 50, 50, 50,
    10, 10, 20, 30, 30, 20, 10, 10,
    5, 5, 10, 25, 25, 10, 5, 5,
    0, 0, 0, 20, 20, 0, 0, 0,
    5, -5, -10, 0, 0, -10, -5, 5,
    5, 10, 10, -20, -20, 10, 10, 5,
    0, 0, 0, 0, 0, 0, 0, 0
]

knight_table = [
    -50, -40, -30, -30, -30, -30, -40, -50,
    -40, -20, 0, 5, 5, 0, -20, -40,
    -30, 5, 10, 15, 15, 10, 5, -30,
    -30, 0, 15, 20, 20, 15, 0, -30,
    -30, 5, 15, 20, 20, 15, 5, -30,
    -30, 0, 10, 15, 15, 10, 0, -30,
    -40, -20, 0, 0, 0, 0, -20, -40,
    -50, -40, -30, -30, -30, -30, -40, -50
]

bishop_table = [
    -20, -10, -10, -10, -10, -10, -10, -20,
    -10, 0, 0, 0, 0, 0, 0, -10,
    -10, 0, 5, 10, 10, 5, 0, -10,
    -10, 5, 5, 10, 10, 5, 5, -10,
    -10, 0, 10, 10, 10, 10, 0, -10,
    -10, 10, 10, 10, 10, 10, 10, -10,
    -10, 5, 0, 0, 0, 0, 5, -10,
    -20, -10, -10, -10, -10, -10, -10, -20
]

rook_table = [
    0, 0, 0, 0, 0, 0, 0, 0,
    5, 10, 10, 10, 10, 10, 10, 5,
    -5, 0, 0, 0, 0, 0, 0, -5,
    -5, 0, 0, 0, 0, 0, 0, -5,
    -5, 0, 0, 0, 0, 0, 0, -5,
    -5, 0, 0, 0, 0, 0, 0, -5,
    -5, 0, 0, 0, 0, 0, 0, -5,
    0, 0, 0, 5, 5, 0, 0, 0
]

queen_table = [
    -20, -10, -10, -5, -5, -10, -10, -20,
    -10, 0, 0, 0, 0, 0, 0, -10,
    -10, 0, 5, 5, 5, 5, 0, -10,
    -5, 0, 5, 5, 5, 5, 0, -5,
    0, 0, 5, 5, 5, 5, 0, -5,
    -10, 5, 5, 5, 5, 5, 0, -10,
    -10, 0, 5, 0, 0, 0, 0, -10,
    -20, -10, -10, -5, -5, -10, -10, -20
]

king_table = [
    -30, -40, -40, -50, -50, -40, -40, -30,
    -30, -40, -40, -50, -50, -40, -40, -30,
    -30, -40, -40, -50, -50, -40, -40, -30,
    -30, -40, -40, -50, -50, -40, -40, -30,
    -20, -30, -30, -40, -40, -30, -30, -20,
    -10, -20, -20, -20, -20, -20, -20, -10,
    20, 20, 0, 0, 0, 0, 20, 20,
    20, 30, 10, 0, 0, 10, 30, 20
]

piece_square_tables = {
    chess.PAWN: pawn_table,
    chess.KNIGHT: knight_table,
    chess.BISHOP: bishop_table,
    chess.ROOK: rook_table,
    chess.QUEEN: queen_table,
    chess.KING: king_table
}


def evaluate_material(board: chess.Board) -> int:
    score = 0
    for square in chess.SQUARES:
        piece = board.piece_at(square)
        if piece:
            piece_value = piece_values[piece.piece_type]
            if piece.color == chess.WHITE:
                score += piece_value
            else:
                score -= piece_value
    return score


def evaluate_piece_square_tables(board: chess.Board) -> int:
    score = 0
    for square in chess.SQUARES:
        piece = board.piece_at(square)
        if piece:
            pst = piece_square_tables[piece.piece_type]
            if piece.color == chess.WHITE:
                score += pst[square]
            else:
                mirrored_square = chess.square_mirror(square)
                score -= pst[mirrored_square]
    return score


def evaluate_pawn_structure(board: chess.Board) -> int:
    score = 0
    for color in [chess.WHITE, chess.BLACK]:
        pawns = list(board.pieces(chess.PAWN, color))
        files = {f: [] for f in range(8)}
        for sq in pawns:
            files[chess.square_file(sq)].append(sq)
        for f in range(8):
            n = len(files[f])
            if n > 1:
                score += (-15 * (n - 1)) if color == chess.WHITE else (15 * (n - 1))
        isolated_files = []
        for f in range(8):
            if len(files[f]) == 0:
                continue
            neighbors = []
            if f > 0:
                neighbors.extend(files[f - 1])
            if f < 7:
                neighbors.extend(files[f + 1])
            if len(neighbors) == 0:
                isolated_files.append(f)
                score += -20 if color == chess.WHITE else 20
        for sq in pawns:
            f = chess.square_file(sq)
            r = chess.square_rank(sq)
            passed = True
            enemy_pawns = board.pieces(chess.PAWN, not color)
            for df in [-1, 0, 1]:
                nf = f + df
                if 0 <= nf <= 7:
                    for ep in enemy_pawns:
                        er = chess.square_rank(ep)
                        ef = chess.square_file(ep)
                        if ef == nf and ((color == chess.WHITE and er > r) or (color == chess.BLACK and er < r)):
                            passed = False
                            break
                    if not passed:
                        break
            if passed:
                bonus = 8 * (r if color == chess.WHITE else 7 - r)
                score += bonus if color == chess.WHITE else -bonus
        for i in range(7):
            if i in isolated_files and (i + 1) in isolated_files:
                score -= 15 if color == chess.WHITE else 15
    return score


def evaluate_bishop_pair(board: chess.Board) -> int:
    score = 0
    for color in [chess.WHITE, chess.BLACK]:
        bishops = list(board.pieces(chess.BISHOP, color))
        if len(bishops) >= 2:
            score += 30 if color == chess.WHITE else -30
    return score


def evaluate_rook_files(board: chess.Board) -> int:
    score = 0
    for color in [chess.WHITE, chess.BLACK]:
        rooks = list(board.pieces(chess.ROOK, color))
        enemy_pawns = list(board.pieces(chess.PAWN, not color))
        friendly_pawns = list(board.pieces(chess.PAWN, color))
        for r_sq in rooks:
            f = chess.square_file(r_sq)
            enemy_file_pawns = [p for p in enemy_pawns if chess.square_file(p) == f]
            friendly_file_pawns = [p for p in friendly_pawns if chess.square_file(p) == f]
            if len(enemy_file_pawns) == 0 and len(friendly_file_pawns) == 0:
                score += 25 if color == chess.WHITE else -25
            elif len(friendly_file_pawns) == 0 and len(enemy_file_pawns) > 0:
                score += 15 if color == chess.WHITE else -15
    return score


def evaluate_knight_outposts(board: chess.Board) -> int:
    score = 0
    for color in [chess.WHITE, chess.BLACK]:
        knights = list(board.pieces(chess.KNIGHT, color))
        enemy_pawns = board.pieces(chess.PAWN, not color)
        for n_sq in knights:
            f = chess.square_file(n_sq)
            r = chess.square_rank(n_sq)
            attacked_by_pawn = False
            for ep in enemy_pawns:
                er = chess.square_rank(ep)
                ef = chess.square_file(ep)
                if color == chess.WHITE and (er + 1 == r) and abs(ef - f) == 1:
                    attacked_by_pawn = True
                    break
                if color == chess.BLACK and (er - 1 == r) and abs(ef - f) == 1:
                    attacked_by_pawn = True
                    break
            if not attacked_by_pawn:
                score += 20 if color == chess.WHITE else -20
    return score


def game_phase(board: chess.Board) -> float:
    max_phase_material = 2 * 320 + 2 * 330 + 2 * 500 + 2 * 900
    current_material = 0
    for piece_type in [chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN]:
        current_material += piece_values[piece_type] * (
            len(board.pieces(piece_type, chess.WHITE)) + len(board.pieces(piece_type, chess.BLACK))
        )
    phase = current_material / max_phase_material
    return max(0.0, min(1.0, phase))


def phase(board: chess.Board) -> float:
    return game_phase(board)


def evaluate_king(board: chess.Board) -> int:
    phase_val = game_phase(board)
    score = 0
    for color in [chess.WHITE, chess.BLACK]:
        king_sq = list(board.pieces(chess.KING, color))[0]
        kr, kf = chess.square_rank(king_sq), chess.square_file(king_sq)
        safety_score = 0
        pawn_dir = 1 if color == chess.WHITE else -1
        ramp_factor = min(board.fullmove_number / 5, 1.0)
        for df in [-1, 0, 1]:
            r = kr + pawn_dir
            f = kf + df
            if 0 <= r <= 7 and 0 <= f <= 7:
                p = board.piece_at(chess.square(f, r))
                if p and p.piece_type == chess.PAWN and p.color == color:
                    safety_score += 10 * ramp_factor
        danger = 0
        for sq in chess.SQUARES:
            p = board.piece_at(sq)
            if p and p.color != color:
                pf, pr = chess.square_file(sq), chess.square_rank(sq)
                dist = abs(kf - pf) + abs(kr - pr)
                if dist <= 2:
                    danger += 5 if p.piece_type != chess.PAWN else 2
        safety_score -= danger
        centralization = -(abs(kf - 3.5) + abs(kr - 3.5)) * 10
        king_score = phase_val * safety_score + (1 - phase_val) * centralization
        score += king_score if color == chess.WHITE else -king_score
    return score


def evaluate_mobility(board: chess.Board) -> int:
    white_score = 0
    black_score = 0
    center = [chess.D4, chess.E4, chess.D5, chess.E5]
    for move in board.legal_moves:
        piece = board.piece_at(move.from_square)
        if not piece:
            continue
        weight = 0
        if piece.piece_type == chess.PAWN:
            rank = chess.square_rank(move.to_square)
            if piece.color == chess.WHITE:
                weight = 7 + rank * 2
            else:
                weight = 6 + (7 - rank) * 2
            if move.to_square in center:
                weight += 15
        elif piece.piece_type == chess.KNIGHT:
            weight = 4
            if board.fullmove_number == 1:
                weight -= 5
        elif piece.piece_type == chess.BISHOP:
            weight = 6
        elif piece.piece_type == chess.ROOK:
            weight = 6
        elif piece.piece_type == chess.QUEEN:
            weight = 10
        else:
            weight = 0
        if piece.color == chess.WHITE:
            white_score += weight
        else:
            black_score += weight
    return white_score - black_score


def evaluate_center_control(board: chess.Board) -> int:
    score = 0
    center = [chess.E4, chess.D4, chess.E5, chess.D5]
    for sq in center:
        piece = board.piece_at(sq)
        if piece:
            if piece.color == chess.WHITE:
                if piece.piece_type == chess.PAWN:
                    score += 80
                else:
                    score += 15
            else:
                if piece.piece_type == chess.PAWN:
                    score -= 80
                else:
                    score -= 15
    return score


def evaluate(board: chess.Board) -> int:
    phase_value = game_phase(board)
    w_material = 1.0
    w_pst = 0.3 + 0.7 * phase_value
    w_pawn_structure = 0.4
    w_bishop_pair = 0.2
    w_knight_outposts = 0.3
    w_rook_files = 0.2
    w_king_safety = 0.6
    w_mobility = 0.3
    w_center = 0.38
    score = 0
    score += w_material * evaluate_material(board)
    score += w_pst * evaluate_piece_square_tables(board)
    score += w_pawn_structure * evaluate_pawn_structure(board)
    score += w_bishop_pair * evaluate_bishop_pair(board)
    score += w_knight_outposts * evaluate_knight_outposts(board)
    score += w_rook_files * evaluate_rook_files(board)
    score += w_king_safety * evaluate_king(board)
    score += w_mobility * phase_value * evaluate_mobility(board)
    score += w_center * evaluate_center_control(board)
    if board.turn == chess.WHITE:
        score += 10
    else:
        score -= 10
    return int(score)
